<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>ãƒã‚ºã®ã‚¹ãƒšãƒ¼ã‚¹ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ¼</title>
  <style>
    :root{
      --bg:#06070b; --line:#1b2a4a; --text:#e9f0ff; --muted:#9fb3d9;
      --accent:#6cf2ff; --good:#76ff9d; --warn:#ffd36c; --bad:#ff6c8b;
      --shadow: 0 14px 40px rgba(0,0,0,.45); --radius: 18px;

      /* iPadã§ã‚‚å´©ã‚Œãªã„ãŸã‚ã®å¯å¤‰ã‚µã‚¤ã‚º */
      --gap: 12px;
      --pad: 12px;

      /* ãƒªãƒ¢ã‚³ãƒ³ã®é«˜ã•ï¼ˆiPadã®Safariãƒãƒ¼ã‚’è€ƒæ…®ã—ã¦ç¸®ã‚€ï¼‰ */
      --remoteH: clamp(70px, 12svh, 110px);
      --slotH:  clamp(44px, 7svh, 54px);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
      background: radial-gradient(1200px 700px at 70% 10%, rgba(108,242,255,.12), transparent 60%),
                  radial-gradient(900px 600px at 20% 90%, rgba(118,255,157,.10), transparent 55%),
                  var(--bg);
      color: var(--text);
      padding:
        env(safe-area-inset-top)
        env(safe-area-inset-right)
        env(safe-area-inset-bottom)
        env(safe-area-inset-left);
    }
    body:before{
      content:""; position:fixed; inset:0; pointer-events:none; opacity:.55;
      background-image:
        radial-gradient(2px 2px at 12% 20%, rgba(255,255,255,.7) 45%, transparent 46%),
        radial-gradient(1px 1px at 38% 55%, rgba(255,255,255,.6) 45%, transparent 46%),
        radial-gradient(1px 1px at 71% 22%, rgba(255,255,255,.5) 45%, transparent 46%),
        radial-gradient(2px 2px at 82% 68%, rgba(255,255,255,.65) 45%, transparent 46%),
        radial-gradient(1px 1px at 60% 82%, rgba(255,255,255,.55) 45%, transparent 46%),
        radial-gradient(1px 1px at 8% 78%, rgba(255,255,255,.45) 45%, transparent 46%);
    }

    /* âœ… iPad Safariã®100vhå•é¡Œå¯¾ç­–ï¼š100dvh / 100svhã‚’ä½¿ã† */
    .app{
      display:grid;
      grid-template-columns: 250px minmax(0, 1fr) 290px;
      grid-template-rows: 1fr var(--remoteH);
      gap: var(--gap);
      height: 100dvh;
      height: 100svh; /* iOSå¯¾ç­– */
      padding: var(--pad);
      min-height: 0;
    }

    .pill{
      background: rgba(18,26,46,.85);
      border:1px solid rgba(27,42,74,.75);
      border-radius:999px; padding:6px 10px;
      display:flex; gap:8px; align-items:center;
      color: var(--muted); font-size:12px;
    }
    .pill b{color:var(--text); font-weight:900}
    .pill .good{color:var(--good); font-weight:900}
    .pill .warn{color:var(--warn); font-weight:900}
    .pill .accent{color:var(--accent); font-weight:900}

    /* âœ… å·¦ï¼šã‚¿ã‚¤ãƒˆãƒ«ï¼‹ã‚³ãƒãƒ³ãƒ‰ */
    .left{
      grid-column: 1 / 2;
      grid-row: 1 / 3;
      background: linear-gradient(180deg, rgba(13,18,32,.95), rgba(10,15,27,.85));
      border: 1px solid rgba(27,42,74,.7);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 10px;
      overflow:hidden;
      display:flex; flex-direction:column; gap: 10px;
      min-height: 0;
    }
    .leftTitle{
      border-radius: 16px;
      padding: 10px 10px;
      background: linear-gradient(180deg, rgba(18,26,46,.95), rgba(12,18,34,.9));
      border: 1px solid rgba(27,42,74,.7);
      box-shadow:
        0 18px 40px rgba(0,0,0,.35),
        inset 0 1px 0 rgba(255,255,255,.08),
        inset 0 -10px 18px rgba(0,0,0,.25);
    }
    .leftTitle h1{margin:0; font-size:18px}
    .leftTitle .sub{margin:2px 0 0; font-size:12px; color:var(--muted)}

    .panelTitle{display:flex; justify-content:space-between; align-items:center}
    .panelTitle h2{margin:0; font-size:14px}
    .panelTitle .hint{font-size:11px; color:var(--muted)}
    .cmdList{overflow:auto; padding-right:6px; display:grid; gap:10px; min-height:0}

    /* âœ… ã‚³ãƒãƒ³ãƒ‰ã‚’3Dã£ã½ã */
    .cmdBtn{
      user-select:none; cursor:pointer;
      border-radius: 16px;
      padding: 10px 12px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      background: linear-gradient(180deg, rgba(25,36,64,.95), rgba(12,18,34,.92));
      border: 1px solid rgba(108,242,255,.18);
      box-shadow:
        0 14px 26px rgba(0,0,0,.35),
        inset 0 1px 0 rgba(255,255,255,.10),
        inset 0 -10px 18px rgba(0,0,0,.35);
      transition: transform .06s ease, border-color .12s ease, box-shadow .12s ease;
    }
    .cmdBtn:hover{
      border-color: rgba(108,242,255,.55);
      box-shadow:
        0 16px 30px rgba(0,0,0,.38),
        inset 0 1px 0 rgba(255,255,255,.14),
        inset 0 -12px 20px rgba(0,0,0,.36);
    }
    .cmdBtn:active{ transform: translateY(1px) scale(.995); }
    .cmdIcon{
      width:42px; height:42px; border-radius:14px;
      display:grid; place-items:center;
      background: linear-gradient(180deg, rgba(108,242,255,.20), rgba(12,18,34,.65));
      border: 1px solid rgba(108,242,255,.25);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.10), inset 0 -10px 14px rgba(0,0,0,.35);
      font-size: 22px;
    }
    .cmdInfo{flex:1}
    .cmdInfo .name{font-weight:900; font-size:13px}
    .cmdInfo .desc{color:var(--muted); font-size:11px; margin-top:2px}
    .cmdAdd{color:var(--accent); font-weight:900; font-size:18px}

    /* âœ… ä¸­å¤®ï¼šãƒãƒƒãƒ—ï¼ˆä¸Šæ®µã„ã£ã±ã„ï¼‰ */
    .mapArea{
      grid-column: 2 / 3;
      grid-row: 1 / 2;
      min-height:0;
      display:flex;
      overflow:hidden;
    }
    .mapCard{
      flex: 1 1 auto;
      min-height:0;
      background: linear-gradient(180deg, rgba(13,18,32,.95), rgba(10,15,27,.85));
      border: 1px solid rgba(27,42,74,.7);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 10px;
      display:flex;
      flex-direction:column;
      overflow:hidden;
      position:relative;
    }

    /* âœ… ãƒœã‚¿ãƒ³ï¼šãƒãƒƒãƒ—å³ä¸Šï¼ˆiPadã§è¦‹åˆ‡ã‚Œãªã„ã‚ˆã†å¸¸ã«ç¢ºä¿ï¼‰ */
    .mapTop{
      flex: 0 0 auto;
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 10px;
      padding: 2px 2px 10px;
      min-height: 54px; /* ã“ã‚ŒãŒåŠ¹ã„ã¦ã€Œã‚¹ã‚¿ãƒ¼ãƒˆãŒéš ã‚Œã‚‹ã€ã‚’é˜²ã */
    }
    .controls{
      margin-left:auto;
      display:flex;
      gap: 8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    button{
      cursor:pointer;
      border-radius: 16px;
      border: 1px solid rgba(108,242,255,.16);
      background: linear-gradient(180deg, rgba(25,36,64,.95), rgba(12,18,34,.92));
      color: var(--text);
      padding: 10px 12px;
      font-weight: 900;
      font-size: 12px;
      min-width: 112px;
      box-shadow:
        0 14px 26px rgba(0,0,0,.35),
        inset 0 1px 0 rgba(255,255,255,.10),
        inset 0 -10px 18px rgba(0,0,0,.35);
      transition: transform .06s ease, border-color .12s ease;
      white-space:nowrap;
    }
    button:hover{ border-color: rgba(108,242,255,.65); }
    button:active{ transform: translateY(1px) scale(.995); }
    button.primary{
      background: linear-gradient(180deg, rgba(108,242,255,.28), rgba(12,18,34,.92));
      border-color: rgba(108,242,255,.55);
    }
    button.danger{
      background: linear-gradient(180deg, rgba(255,108,139,.18), rgba(12,18,34,.92));
      border-color: rgba(255,108,139,.55);
    }
    button:disabled{opacity:.5; cursor:not-allowed}

    .canvasWrap{
      flex: 1 1 auto;
      min-height:0;
      border-radius: 14px;
      border: 1px solid rgba(27,42,74,.7);
      background: rgba(6,7,11,.25);
      overflow:hidden;
    }
    canvas{width:100%; height:100%; display:block}

    /* âœ… å³ï¼šã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ */
    .status{
      grid-column: 3 / 4;
      grid-row: 1 / 2;
      background: linear-gradient(180deg, rgba(13,18,32,.95), rgba(10,15,27,.85));
      border: 1px solid rgba(27,42,74,.7);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 10px;
      overflow:hidden;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .status h2{margin:0; font-size:14px}
    .statusGrid{display:grid; gap:10px}
    .statusNote{margin-top:auto; color:var(--muted); font-size:11px; line-height:1.5}

    /* âœ… ä¸‹ï¼šãƒªãƒ¢ã‚³ãƒ³ï¼ˆiPadã§ã€Œã¯ã¿å‡ºã™ã€å¯¾ç­–ï¼šæ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã«ã™ã‚‹ï¼‰ */
    .remote{
      grid-column: 2 / 4;
      grid-row: 2 / 3;
      background: linear-gradient(180deg, rgba(13,18,32,.95), rgba(10,15,27,.85));
      border: 1px solid rgba(27,42,74,.7);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 6px 10px 8px 10px;
      display:flex; flex-direction:column; gap:6px;
      overflow:hidden;
      min-height:0;
    }
    .remoteTop{display:flex; justify-content:space-between; gap:10px; align-items:center}
    .remoteTop .label{font-weight:900; font-size:13px}
    .remoteTop .small{color:var(--muted); font-size:11px}

    /* iPadã§æ¨ªå¹…ãŒè¶³ã‚Šãªã„æ™‚ã‚‚å´©ã‚Œãªã„ï¼šæ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« */
    .slots{
      display:flex;
      gap: 8px;
      overflow-x:auto;
      overflow-y:hidden;
      padding-bottom: 2px;
      -webkit-overflow-scrolling: touch;
    }
    .slot{
      flex: 0 0 auto;
      width: clamp(54px, 8vw, 86px);
      height: var(--slotH);
      user-select:none;
      border-radius: 14px;
      display:grid; place-items:center;
      font-weight:900; font-size:18px;
      position:relative;
      color: rgba(233,240,255,.75);

      /* 3Dã£ã½ã */
      background: linear-gradient(180deg, rgba(25,36,64,.85), rgba(12,18,34,.92));
      border: 1px dashed rgba(108,242,255,.16);
      box-shadow:
        0 14px 26px rgba(0,0,0,.32),
        inset 0 1px 0 rgba(255,255,255,.10),
        inset 0 -10px 18px rgba(0,0,0,.35);
    }
    .slot.filled{
      border-style:solid;
      background: linear-gradient(180deg, rgba(108,242,255,.18), rgba(12,18,34,.92));
      border-color: rgba(108,242,255,.35);
    }
    .slot .idx{position:absolute; left:8px; top:6px; font-size:10px; color: rgba(159,179,217,.8); font-weight:900;}
    .slot .x{
      position:absolute; right:6px; top:6px;
      font-size:12px; color: rgba(255,108,139,.95);
      font-weight:900; display:none; cursor:pointer;
      padding:2px 6px; border-radius:10px;
      background: rgba(255,108,139,.12);
      border: 1px solid rgba(255,108,139,.25);
    }
    .slot.filled .x{display:block}
    .slot.active{outline:2px solid rgba(118,255,157,.8); box-shadow:0 0 0 6px rgba(118,255,157,.10);}

    /* âœ… ã‚¯ãƒªã‚¢ç”»é¢ï¼ˆæ–‡å­—ã‚’å¤§ããï¼‰ */
    .overlay{
      position:fixed; inset:0;
      background: rgba(0,0,0,.62);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 8px;
      z-index: 20;
    }
    .overlay.show{display:flex}
    .modal{
      width:min(1100px, 98vw);
      background: linear-gradient(180deg, rgba(13,18,32,.97), rgba(10,15,27,.92));
      border: 1px solid rgba(108,242,255,.35);
      border-radius: 22px;
      box-shadow: 0 24px 80px rgba(0,0,0,.65);
      padding: 14px;
      display:flex; flex-direction:column; gap:10px;
    }
    .modal h3{
      margin:0;
      font-size: clamp(26px, 4vw, 44px);
      letter-spacing: .06em;
      text-shadow: 0 10px 22px rgba(0,0,0,.55);
    }
    .modal p{margin:0; color:var(--muted); font-size:12px; line-height:1.5}
    .modal .anim{
      height: 62vh;
      border-radius: 16px;
      border: 1px solid rgba(27,42,74,.7);
      background:
        radial-gradient(800px 380px at 50% 120%, rgba(108,242,255,.18), transparent 55%),
        radial-gradient(700px 320px at 70% 10%, rgba(118,255,157,.12), transparent 60%),
        rgba(6,7,11,.35);
      display:flex; align-items:center; justify-content:center;
      overflow:hidden;
      position:relative;
    }
    .nextSpaceImg{
      max-height: 58vh;
      max-width: 96vw;
      border-radius:14px;
      border:1px solid rgba(108,242,255,.25);
      box-shadow: 0 10px 40px rgba(0,0,0,.35);
    }

    /* âœ… ã¤ãã¸å‹•ç”»ï¼ˆiOSå†ç”Ÿç”¨ï¼‰ */
    .nextVideo{
      width: min(980px, 96vw);
      max-height: 58vh;
      border-radius:14px;
      border:1px solid rgba(108,242,255,.25);
      box-shadow: 0 10px 40px rgba(0,0,0,.35);
      background:#000;
      display:none;
    }
    .nextVideo.show{display:block}

    /* âœ… èµ·å‹•ç”»é¢ */
    .startOverlay{
      position:fixed; inset:0;
      background: rgba(0,0,0,.72);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 10px;
      z-index: 30;
    }
    .startCard{
      width:min(980px, 96vw);
      background: linear-gradient(180deg, rgba(13,18,32,.97), rgba(10,15,27,.92));
      border: 1px solid rgba(108,242,255,.35);
      border-radius: 22px;
      box-shadow: 0 24px 80px rgba(0,0,0,.65);
      padding: 14px;
      display:flex; flex-direction:column; gap:12px;
      align-items:center;
    }
    .startImg{
      width:100%;
      max-height: 60vh;
      object-fit: contain;
      border-radius: 16px;
      border: 1px solid rgba(27,42,74,.7);
      background: rgba(6,7,11,.35);
    }

    /* âœ… iPadæ¨ª(1024å‰å¾Œ)ã§ã•ã‚‰ã«å®‰å®šã•ã›ã‚‹ */
    @media (max-width: 1100px){
      :root{ --remoteH: clamp(66px, 11svh, 100px); }
      .app{ grid-template-columns: 240px minmax(0, 1fr) 280px; }
      button{ min-width: 104px; padding: 10px 10px; }
    }

    @media (max-width: 980px){
      /* ç¸¦æŒã¡ç”¨ */
      body{overflow:auto}
      .app{
        height:auto;
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto auto;
      }
      .left{grid-column:1; grid-row:auto}
      .mapArea{grid-column:1; grid-row:auto; height: 62vh;}
      .status{grid-column:1; grid-row:auto}
      .remote{grid-column:1; grid-row:auto}
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="left">
      <div class="leftTitle">
        <h1>ãƒã‚ºã®ã‚¹ãƒšãƒ¼ã‚¹ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ¼</h1>
        <div class="sub">ã‚³ãƒãƒ³ãƒ‰ã‚’ ãªã‚‰ã¹ã¦ã€ãƒã‚ºã‚’ ãƒ­ã‚±ãƒƒãƒˆã¸ï¼</div>
      </div>

      <div class="panelTitle">
        <h2>ã‚³ãƒãƒ³ãƒ‰</h2>
        <div class="hint">ã‚¿ãƒƒãƒ—ã§ ã„ã‚Œã‚‹</div>
      </div>
      <div class="cmdList" id="cmdList"></div>

      <div style="margin-top:auto; font-size:11px; color:var(--muted); line-height:1.4;">
        ã‚ãã³ã‹ãŸï¼š<br/>
        ãƒ»ã‚³ãƒãƒ³ãƒ‰ã‚’ ãªã‚‰ã¹ã¦ <b>ã‚¹ã‚¿ãƒ¼ãƒˆ</b><br/>
        ãƒ»ãƒ†ãƒ¼ãƒ—ã‚’ ã¨ã£ã¦ã€ã‚¯ãƒ«ãƒ¼ã« ã‚ã†ã¨ ãŸã‹ã„ï¼<br/>
        ãƒ»ãƒ­ã‚±ãƒƒãƒˆã« ã¤ã„ãŸã‚‰ ã‚¯ãƒªã‚¢ï¼
      </div>
    </aside>

    <section class="mapArea">
      <div class="mapCard">
        <div class="mapTop">
          <div class="controls">
            <button class="primary" id="btnStart">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
            <button id="btnReset">ãƒªã‚»ãƒƒãƒˆ</button>
            <button id="btnShuffle" style="display:none; background:#8e44ad;">è¿·è·¯ã‚’ãã¿ã‹ãˆã‚‹</button>
            <button class="danger" id="btnClear">ã‚³ãƒãƒ³ãƒ‰ ãœã‚“ã¶ã‘ã™</button>
          </div>
        </div>
        <div class="canvasWrap">
          <canvas id="gameCanvas"></canvas>
        </div>
      </div>
    </section>

    <aside class="status">
      <h2>ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</h2>
      <div class="statusGrid">
        <div class="pill">ã‚¹ãƒ†ãƒ¼ã‚¸ <b id="stageText">1</b> / <span class="accent" id="stageMaxText">4</span></div>
        <div class="pill">ãƒãƒƒãƒ— <b id="sizeText">4Ã—4</b></div>
        <div class="pill">ã‚¹ã‚³ã‚¢ <b class="good" id="scoreText">0</b></div>
        <div class="pill">ãƒ†ãƒ¼ãƒ— <b class="warn" id="tapeText">0</b></div>
        <div class="pill">ã‚¯ãƒ«ãƒ¼ <b class="accent" id="crewText">0</b></div>
      </div>
      <div class="statusNote">
        â€» ã—ã£ã±ã„ã—ãŸã‚‰ ã˜ã©ã†ã§ ã‚‚ã©ã‚‹ã‚ˆ<br/>
        â€» ã‚¹ã‚¿ãƒ¼ãƒˆã™ã‚‹ã¨ ã‚³ãƒãƒ³ãƒ‰ã¯ ããˆã‚‹ã‚ˆ
      </div>
    </aside>

    <section class="remote">
      <div class="remoteTop">
        <div class="label">ãƒªãƒ¢ã‚³ãƒ³</div>
        <div class="small">ã‚¹ãƒ­ãƒƒãƒˆã‚’ã‚¿ãƒƒãƒ—ã§ ã‘ã›ã‚‹ï¼ˆæ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«OKï¼‰</div>
      </div>
      <div class="slots" id="slots"></div>
    </section>
  </div>

  <!-- èµ·å‹•ç”»é¢ -->
  <div class="startOverlay" id="startOverlay">
    <div class="startCard">
      <img class="startImg" id="startImg" alt="ã¯ã˜ã‚ã‚‹" />
      <button class="primary" id="btnBegin" style="min-width:180px;">ã¯ã˜ã‚ã‚‹</button>
    </div>
  </div>

  <!-- ã‚¯ãƒªã‚¢ç”»é¢ -->
  <div class="overlay" id="overlay">
    <div class="modal">
      <h3>ã‚¯ãƒªã‚¢ï¼</h3>
      <p>ãƒã‚ºãŒ ãƒ­ã‚±ãƒƒãƒˆã« ã®ã£ã¦ã€ã¤ãã® ã†ã¡ã‚…ã†ã¸ï¼</p>
      <div class="anim">
        <img id="nextSpaceImg" class="nextSpaceImg" alt="ã¤ãã® ã†ã¡ã‚…ã†" />
        <video id="nextVideo" class="nextVideo" playsinline webkit-playsinline></video>
      </div>
      <div style="display:flex; justify-content:space-between; width:100%;">
        <button id="btnSkip" style="display:none; background:rgba(255,255,255,0.15); border:1px solid rgba(255,255,255,0.3);">ã‚¹ã‚­ãƒƒãƒ—</button>
        <button id="btnNext" class="primary">ã¤ãã¸</button>
      </div>
    </div>
  </div>

<script>
(() => {
  /***********************
   * ç”»åƒ
   ***********************/
  const IMG = {
    buzzUp:   "ãƒã‚ºä¸Š.png",
    buzzRight:"ãƒã‚ºå³.png",
    buzzDown: "ãƒã‚ºä¸‹.png",
    buzzLeft: "ãƒã‚ºå·¦.png",

    crew1: "çŒ«ãƒã‚¹.png",
    crew2: "ãƒˆãƒˆãƒ­.png",
    crew3: "ãƒ¡ã‚¤.png",
    rocket: "ãƒ­ã‚±ãƒƒãƒˆ.png",
    tape: "ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚·ãƒ¼ãƒ«ãƒ‰ãƒ†ãƒ¼ãƒ—.png",
    mama: "ãƒãƒ.png",             // âœ… è¿½åŠ 
    kaiju: "ã‚†ã‚æ€ªç£.png",         // âœ… è¿½åŠ 
    nextSpace: "ãƒã‚ºå®‡å®™ã¸.png",

    startImg: "ã¯ã˜ã‚ã‚‹.png"
  };

  /***********************
   * éŸ³ãƒ»å‹•ç”»
   ***********************/
  const SND = {
    goalSfx: "ã‚´ãƒ¼ãƒ«.mp3",
    cmdSfx:  "ã‚³ãƒãƒ³ãƒ‰é¸æŠ.mp3",
    walkSfx: "æ­©è¡ŒéŸ³.mp3",         // âœ… è¿½åŠ 
    goalBgm: "ã‚´ãƒ¼ãƒ«BGM.mp3",
    playBgm: "ãƒ—ãƒ¬ã‚¤ä¸­BGM.mp3",

    beginBgm: "ã¯ã˜ã‚ã‚‹BGM.mp3",   // âœ… èµ·å‹•ç”»é¢BGM
    beginBtn: "ã¯ã˜ã‚ã‚‹ãƒœã‚¿ãƒ³.mp3",// âœ… ã¯ã˜ã‚ã‚‹æŠ¼ä¸‹
    nextSfx:  "ã¤ãã¸.mp3",        // âœ… ã¤ãã¸éŸ³
    mamaSfx:  "ãƒãƒå‹•ç”».mp3",      // âœ… è¿½åŠ 
    yuaSfx:   "ã‚†ã‚å‹•ç”».mp3"       // âœ… è¿½åŠ 
  };
  const MOV = {
    nextMp4: "ã¤ãã¸.mp4",         // âœ… ã¤ãã¸å‹•ç”»
    mamaMp4: "ãƒãƒå‹•ç”».mp4",       // âœ… è¿½åŠ 
    yuaMp4:  "ã‚†ã‚å‹•ç”».mp4"        // âœ… è¿½åŠ 
  };

  let audioUnlocked = false;

  // BGM
  const playBGM  = new Audio(SND.playBgm);
  playBGM.loop = true;  playBGM.volume = 0.35;

  const goalBGM  = new Audio(SND.goalBgm);
  goalBGM.loop = true;  goalBGM.volume = 0.45;

  const beginBGM = new Audio(SND.beginBgm);
  beginBGM.loop = true; beginBGM.volume = 0.45;

  function unlockAudio(){
    if (audioUnlocked) return;
    audioUnlocked = true;
    // iOSå¯¾ç­–ï¼šä¸€åº¦ play ã—ã¦å³åœæ­¢
    [playBGM, goalBGM, beginBGM].forEach(a=>{
      a.play().then(()=>{ a.pause(); a.currentTime=0; }).catch(()=>{});
    });
  }

  function playSfx(src, volume=0.9){
    if (!audioUnlocked) return;
    const a = new Audio(src);
    a.volume = volume;
    a.play().catch(()=>{});
  }

  function startPlayBGM(){
    if (!audioUnlocked) return;
    try { goalBGM.pause(); goalBGM.currentTime = 0; } catch(_){}
    try { beginBGM.pause(); beginBGM.currentTime = 0; } catch(_){}
    if (!playBGM.paused) return;
    playBGM.currentTime = 0;
    playBGM.play().catch(()=>{});
  }
  function stopPlayBGM(){ try { playBGM.pause(); } catch(_){} }

  function startGoalBGM(){
    if (!audioUnlocked) return;
    try { playBGM.pause(); playBGM.currentTime = 0; } catch(_){}
    try { beginBGM.pause(); beginBGM.currentTime = 0; } catch(_){}
    goalBGM.currentTime = 0;
    goalBGM.play().catch(()=>{});
  }
  function stopGoalBGM(){ try { goalBGM.pause(); } catch(_){} }

  function startBeginBGM(){
    // èµ·å‹•ç”»é¢ã¯ã‚¿ãƒƒãƒ—å‰ã¯é³´ã‚‰ãªã„ã®ã§ã€æŠ¼ä¸‹å¾Œã«é³´ã‚‰ã™ï¼ˆiOSä»•æ§˜ï¼‰
    if (!audioUnlocked) return;
    try { playBGM.pause(); playBGM.currentTime = 0; } catch(_){}
    try { goalBGM.pause(); goalBGM.currentTime = 0; } catch(_){}
    if (!beginBGM.paused) return;
    beginBGM.currentTime = 0;
    beginBGM.play().catch(()=>{});
  }
  function stopBeginBGM(){ try { beginBGM.pause(); } catch(_){} }

  /**
   * æ±ç”¨å‹•ç”»å†ç”Ÿæ©Ÿèƒ½
   * ä»»æ„ã®å‹•ç”»ã¨éŸ³å£°ã‚’å†ç”Ÿã—ã€çµ‚ã‚ã£ãŸã‚‰æŒ‡å®šã®callbackã‚’å®Ÿè¡Œã™ã‚‹
   */
  async function playInterruptVideo(mp3Src, mp4Src, onComplete) {
    // 1. ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’ä¸€æ™‚åœæ­¢
    stopRun();

    // 2. BGMã‚’æ­¢ã‚ã‚‹
    stopPlayBGM();
    stopGoalBGM();
    stopBeginBGM();

    // 3. ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’è¡¨ç¤ºã—ã€Canvasã‚„æ¬¡ã®ç”»åƒã‚’éš ã—ã¦å‹•ç”»ã‚’è¡¨ç¤º
    nextSpaceImgEl.style.display = "none";
    nextVideoEl.classList.add("show");
    overlay.classList.add("show");

    // 4. éŸ³å£°ã‚’å†ç”Ÿã—ã€å‹•ç”»ã‚’å†ç”Ÿ
    playSfx(mp3Src, 1.0);
    nextVideoEl.src = mp4Src;
    nextVideoEl.currentTime = 0;
    nextVideoEl.muted = false;
    nextVideoEl.controls = false;

    const endHandler = () => {
      cleanup();
      if (onComplete) onComplete();
    };

    const cleanup = () => {
      nextVideoEl.removeEventListener("ended", endHandler);
      nextVideoEl.pause();
      nextVideoEl.removeAttribute("src");
      nextVideoEl.load();
      nextVideoEl.classList.remove("show");
      overlay.classList.remove("show");
    };

    nextVideoEl.addEventListener("ended", endHandler, { once: true });

    try {
      await nextVideoEl.play();
    } catch (e) {
      // iOS/Safariå¯¾ç­–ï¼šplayãŒå¤±æ•—ã—ãŸå ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      nextVideoEl.controls = true;
      try { await nextVideoEl.play(); } catch (_) {}
    }
  }

  /***********************
   * ç”»åƒãƒ­ãƒ¼ãƒ‰
   ***********************/
  function loadImg(src){
    const img = new Image();
    let ok = false;
    const ready = new Promise((resolve) => {
      img.onload = () => { ok = true; resolve(true); };
      img.onerror = () => { ok = false; resolve(false); };
    });
    img.src = src;
    return { img, ready, ok: () => ok };
  }

  const I = {
    buzzUp: loadImg(IMG.buzzUp),
    buzzRight: loadImg(IMG.buzzRight),
    buzzDown: loadImg(IMG.buzzDown),
    buzzLeft: loadImg(IMG.buzzLeft),
    crew1: loadImg(IMG.crew1),
    crew2: loadImg(IMG.crew2),
    crew3: loadImg(IMG.crew3),
    rocket: loadImg(IMG.rocket),
    tape: loadImg(IMG.tape),
    mama: loadImg(IMG.mama),
    kaiju: loadImg(IMG.kaiju),
    nextSpace: loadImg(IMG.nextSpace),
    startImg: loadImg(IMG.startImg),
  };

  function buzzImgForDir(dir){
    if (dir===0) return I.buzzUp;
    if (dir===1) return I.buzzRight;
    if (dir===2) return I.buzzDown;
    return I.buzzLeft;
  }

  /***********************
   * ã‚²ãƒ¼ãƒ è¨­å®š
   ***********************/
  // âœ… ã‚¹ãƒ†ãƒ¼ã‚¸æ§‹æˆã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåŒ–
  const STAGES = [
    { size:4,  maze:false, items:["tape"], crews:3, enemies:[] },
    { size:6,  maze:false, items:["tape"], crews:3, enemies:[] },
    { size:8,  maze:false, items:["tape"], crews:3, enemies:[] },
    // Stage 4 (10x10) ã¯å‰Šé™¤
    // è¿½åŠ ã‚¹ãƒ†ãƒ¼ã‚¸
    { size:7,  maze:true,  items:[],       crews:0, enemies:[] },         // 4: æœ¬æ ¼è¿·è·¯
    { size:9,  maze:true,  items:["mama"], crews:0, enemies:[] },         // 5: ãƒãƒã¨ã„ã£ã—ã‚‡
    { size:9,  maze:true,  items:[],       crews:0, enemies:["kaiju"] },  // 6: é¬¼ã”ã£ã“
    { size:9,  maze:true,  items:["mama"], crews:0, enemies:["kaiju"] },  // 7: ãƒãƒï¼†é¬¼ã”ã£ã“ï¼ˆæ–°ã‚¹ãƒ†ãƒ¼ã‚¸ï¼‰
  ];
  let stageIndex = 0;

  const COMMANDS = [
    { id:"F", name:"ã¾ãˆã¸", icon:"â¬†ï¸", desc:"1ãƒã‚¹ã™ã™ã‚€" },
    { id:"U", name:"ãµã‚Šã‹ãˆã‚Š", icon:"ğŸ”„", desc:"ã†ã—ã‚ã‚’ã‚€ã" }, // 180åº¦å›è»¢ã ã‘
    { id:"L", name:"ã²ã ã‚Š", icon:"â†©ï¸", desc:"ã²ã ã‚Šã«ã‚€ã" },
    { id:"R", name:"ã¿ã",   icon:"â†ªï¸", desc:"ã¿ãã«ã‚€ã" },
  ];

  const MAX_SLOTS = 10;

  const state = {
    config: STAGES[stageIndex], // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸è¨­å®š
    size: STAGES[stageIndex].size,
    board: [],         // âœ… 0=åºŠ, 1=å£
    running:false,
    tickMs: 420,
    stepPtr:0,
    score:0, tapeGot:0, crewMet:0,
    start:{x:0,y:0,dir:0},
    buzz:{x:0,y:0,dir:0},
    goal:{x:0,y:0},
    crews:[],
    items:[],          // âœ… æ±ç”¨ã‚¢ã‚¤ãƒ†ãƒ ãƒªã‚¹ãƒˆ {x,y,type,got}
    enemies:[],        // âœ… æ•µãƒªã‚¹ãƒˆ {x,y,type}
    turn:0,            // âœ… ã‚¿ãƒ¼ãƒ³æ•°ï¼ˆæ•µç§»å‹•ç”¨ï¼‰
    slots: new Array(MAX_SLOTS).fill(null),
    runQueue: [],
    message:"",
    kaijuCatchCount: 0 // âœ… è¿½åŠ ï¼šæ€ªç£ã«æ•ã¾ã£ãŸå›æ•°
  };

  /***********************
   * DOM
   ***********************/
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const stageText = document.getElementById("stageText");
  const stageMaxText = document.getElementById("stageMaxText");
  const sizeText = document.getElementById("sizeText");
  const scoreText = document.getElementById("scoreText");
  const tapeText = document.getElementById("tapeText");
  const crewText = document.getElementById("crewText");

  const cmdList = document.getElementById("cmdList");
  const slotsEl = document.getElementById("slots");

  const btnStart = document.getElementById("btnStart");
  const btnReset = document.getElementById("btnReset");
  const btnClear = document.getElementById("btnClear");
  const btnShuffle = document.getElementById("btnShuffle"); // âœ… è¿½åŠ 

  const overlay = document.getElementById("overlay");
  const btnNext = document.getElementById("btnNext");
  const btnSkip = document.getElementById("btnSkip"); // âœ… è¿½åŠ 
  const nextSpaceImgEl = document.getElementById("nextSpaceImg");
  const nextVideoEl = document.getElementById("nextVideo");

  const startOverlay = document.getElementById("startOverlay");
  const btnBegin = document.getElementById("btnBegin");
  const startImgEl = document.getElementById("startImg");

  let started = false;

  Promise.all([
    I.buzzUp.ready, I.buzzRight.ready, I.buzzDown.ready, I.buzzLeft.ready,
    I.crew1.ready, I.crew2.ready, I.crew3.ready,
    I.rocket.ready, I.tape.ready, I.mama.ready, I.kaiju.ready,
    I.nextSpace.ready, I.startImg.ready
  ]).then(() => {
    nextSpaceImgEl.src = IMG.nextSpace;
    startImgEl.src = IMG.startImg;
    fitCanvas();
    draw();
  });

  /***********************
   * UI
   ***********************/
  function iconForCmd(id){ return (COMMANDS.find(x=>x.id===id) || {}).icon || "?"; }

  function buildCmdList(){
    cmdList.innerHTML = "";
    COMMANDS.forEach(c => {
      const div = document.createElement("div");
      div.className = "cmdBtn";
      div.innerHTML = `
        <div class="cmdIcon">${c.icon}</div>
        <div class="cmdInfo">
          <div class="name">${c.name}</div>
          <div class="desc">${c.desc}</div>
        </div>
        <div class="cmdAdd">ï¼‹</div>
      `;
      div.addEventListener("click", () => {
        if (!started) return;            // èµ·å‹•ç”»é¢ä¸­ã¯ç„¡åŠ¹
        unlockAudio();
        startPlayBGM();
        addCommandToSlots(c.id);
      });
      cmdList.appendChild(div);
    });
  }

  function buildSlots(){
    slotsEl.innerHTML = "";
    for (let i=0;i<MAX_SLOTS;i++){
      const s = document.createElement("div");
      s.className = "slot";
      s.innerHTML = `<div class="idx">${i+1}</div><div class="val"></div><div class="x">Ã—</div>`;
      s.addEventListener("click", () => {
        if (!started) return;
        if (state.running) return;
        if (state.slots[i]){ state.slots[i] = null; renderSlots(); draw(); }
      });
      s.querySelector(".x").addEventListener("click", (e) => {
        e.stopPropagation();
        if (!started) return;
        if (state.running) return;
        state.slots[i] = null; renderSlots(); draw();
      });
      slotsEl.appendChild(s);
    }
    renderSlots();
  }

  function renderSlots(){
    for (let i=0;i<MAX_SLOTS;i++){
      const el = slotsEl.children[i];
      const v = state.slots[i];
      el.classList.toggle("filled", !!v);
      el.classList.toggle("active", state.running && i === state.stepPtr);
      el.querySelector(".val").textContent = v ? iconForCmd(v) : "";
    }
  }

  function addCommandToSlots(cmdId){
    if (state.running) return;
    const idx = state.slots.findIndex(v => v === null);
    if (idx === -1) return;
    state.slots[idx] = cmdId;
    renderSlots(); draw();
    playSfx(SND.cmdSfx, 0.9);
  }

  function clearCommands(){
    if (state.running) return;
    state.slots = new Array(MAX_SLOTS).fill(null);
    state.stepPtr = 0;
    state.message = "ã‚³ãƒãƒ³ãƒ‰ ãœã‚“ã¶ ã‘ã—ãŸã‚ˆï¼";
    renderSlots(); draw();
  }

  /***********************
   * ã‚¹ãƒ†ãƒ¼ã‚¸ç”Ÿæˆ
   ***********************/
  function randInt(n){ return Math.floor(Math.random()*n); }
  function key(x,y){ return `${x},${y}`; }
  function manhattan(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }

  function validDirsForStart(x,y){
    const ds = [];
    if (y-1 >= 0) ds.push(0);
    if (x+1 < state.size) ds.push(1);
    if (y+1 < state.size) ds.push(2);
    if (x-1 >= 0) ds.push(3);
    return ds;
  }

  function pickStartGoalFar(){
    const minDist = Math.max(3, Math.floor(state.size * 1.1));
    let s, g, guard=0;
    do{
      const sx = randInt(state.size);
      const sy = randInt(state.size);
      const dirs = validDirsForStart(sx, sy);
      const dir = dirs[randInt(dirs.length)];
      s = {x:sx, y:sy, dir};
      g = {x:randInt(state.size), y:randInt(state.size)};
      guard++;
      if (guard > 1500) break;
    } while ((s.x===g.x && s.y===g.y) || manhattan(s,g) < minDist);
    return {s, g};
  }

  /***********************
   * è¿·è·¯ç”Ÿæˆ (ç©´æ˜ã‚Šæ³•ï¼šæ¨™æº–)
   ***********************/
  function generateMaze(w, h){
    // 1. ã¾ãšå…¨ã¦ã‚’ã€Œå£(1)ã€ã§åŸ‹ã‚ã‚‹
    const board = [];
    for(let y=0; y<h; y++){
      board.push(new Array(w).fill(1));
    }

    // 2. ç©´æ˜ã‚Šè·äºº (ä¸­èº«ã®è¿·è·¯ã‚’ä½œã‚‹)
    function dig(x, y){
      board[y][x] = 0;

      const dirs = [
        {dx:0, dy:-2}, {dx:0, dy: 2}, 
        {dx:-2, dy: 0}, {dx: 2, dy: 0}
      ].sort(() => Math.random() - 0.5);

      for(let d of dirs){
        const nx = x + d.dx;
        const ny = y + d.dy;
        const wx = x + d.dx / 2;
        const wy = y + d.dy / 2;

        if (nx > 0 && nx < w && ny > 0 && ny < h && board[ny][nx] === 1){
          board[wy][wx] = 0;
          dig(nx, ny);
        }
      }
    }

    // è¿·è·¯ç”Ÿæˆã‚’å®Ÿè¡Œ
    dig(1, 1);

    // é¬¼ã”ã£ã“ç”¨ã®èª¿æ•´ï¼ˆå†…éƒ¨ã®å£ã‚’å°‘ã—æ¸›ã‚‰ã—ã¦é€ƒã’ã‚„ã™ãã™ã‚‹ï¼‰
    if (stageIndex >= 5) {
      for(let i=0; i<12; i++){
        let rx = randInt(w-2)+1;
        let ry = randInt(h-2)+1;
        if(board[ry][rx] === 1) board[ry][rx] = 0;
      }
    }
    
    return board;
  }



  function randomEmptyCell(occ){
    let guard=0;
    while(true){
      const c = {x:randInt(state.size), y:randInt(state.size)};
      // å£(1)ã¯ãƒ€ãƒ¡
      if (state.board[c.y] && state.board[c.y][c.x] === 1) continue;

      const k = key(c.x,c.y);
      if (!occ.has(k)) return c;
      guard++; if (guard>5000) return c;
    }
  }

  let timer=null;

  /**
   * ã‚¹ã‚¿ãƒ¼ãƒˆã¨ã‚´ãƒ¼ãƒ«ã®é…ç½®ï¼ˆè¿·è·¯ã®é“ã®ã‚Šã§æœ€ã‚‚é ã„å ´æ‰€ã‚’é¸ã¶ï¼‰
   */
  function pickStartGoalFar(){
    const hasFloor = state.board.flat().includes(0);
    if (!hasFloor) return { s: {x:0,y:0,dir:0}, g: {x:0,y:0} };

    // 1. ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã‚’ãƒ©ãƒ³ãƒ€ãƒ ãªã€ŒåºŠ(0)ã€ã‹ã‚‰é¸ã¶
    let sx, sy;
    do {
      sx = randInt(state.size);
      sy = randInt(state.size);
    } while(state.board[sy][sx] === 1);

    // 2. BFSã§å…¨ãƒã‚¹ã®æœ€çŸ­æ­©æ•°ã‚’è¨ˆç®—
    const dists = Array.from({ length: state.size }, () => new Array(state.size).fill(-1));
    const q = [{ x: sx, y: sy, d: 0 }];
    dists[sy][sx] = 0;

    let maxDist = 0;
    let furthestCells = [{ x: sx, y: sy }];

    while (q.length > 0) {
      const cur = q.shift();
      const dirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
      
      for (const d of dirs) {
        const nx = cur.x + d.dx;
        const ny = cur.y + d.dy;
        if (nx >= 0 && nx < state.size && ny >= 0 && ny < state.size && state.board[ny][nx] === 0 && dists[ny][nx] === -1) {
          const nd = cur.d + 1;
          dists[ny][nx] = nd;
          q.push({ x: nx, y: ny, d: nd });

          if (nd > maxDist) {
            maxDist = nd;
            furthestCells = [{ x: nx, y: ny }];
          } else if (nd === maxDist) {
            furthestCells.push({ x: nx, y: ny });
          }
        }
      }
    }

    // 3. æœ€ã‚‚é ã„ãƒã‚¹ã®ä¸­ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«ã‚´ãƒ¼ãƒ«ã‚’é¸ã¶
    const g = furthestCells[randInt(furthestCells.length)];
    
    // å‘ãæ±ºå®šï¼ˆå£ã«å‘ã‹ãªã„ã‚ˆã†ã«ã™ã‚‹ï¼‰
    const startDirs = validDirsForStart(sx, sy);
    const s = { x: sx, y: sy, dir: startDirs.length ? startDirs[randInt(startDirs.length)] : 0 };

    return { s, g };
  }

  function stopRun(){
    state.running=false;
    btnStart.disabled=false;
    btnReset.disabled=false;
    btnClear.disabled=false;
    if (timer){ clearInterval(timer); timer=null; }
  }

  function updateHUD(){
    stageText.textContent = String(stageIndex+1);
    stageMaxText.textContent = String(STAGES.length);
    sizeText.textContent = `${state.size}Ã—${state.size}`;
    scoreText.textContent = String(state.score);
    tapeText.textContent = String(state.tapeGot);
    crewText.textContent = String(state.crewMet);
  }

  function resetStage(){
    stopRun();
    stopGoalBGM();
    startPlayBGM();

    state.config = STAGES[stageIndex];
    state.size = state.config.size;
    state.stepPtr = 0;
    state.message = "";
    state.turn = 0;

    // ãƒãƒƒãƒ—ç”Ÿæˆ
    if (state.config.maze){
      state.board = generateMaze(state.size, state.size);
      btnShuffle.style.display = "inline-block"; // è¿·è·¯ã‚¹ãƒ†ãƒ¼ã‚¸ãªã‚‰è¡¨ç¤º
    } else {
      // å…¨ã¦åºŠ(0)
      state.board = [];
      for(let y=0; y<state.size; y++){
        state.board.push(new Array(state.size).fill(0));
      }
      btnShuffle.style.display = "none"; // è¿·è·¯ã§ãªã„ãªã‚‰éè¡¨ç¤º
    }

    const {s, g} = pickStartGoalFar();
    state.start = {x:s.x, y:s.y, dir:s.dir};
    state.buzz  = {x:s.x, y:s.y, dir:s.dir};
    state.goal  = {x:g.x, y:g.y};

    const occ = new Set([ key(state.start.x,state.start.y), key(state.goal.x,state.goal.y) ]);

    // ã‚¯ãƒ«ãƒ¼é…ç½®
    state.crews = [];
    for (let i=0; i<state.config.crews; i++){
      const c = randomEmptyCell(occ);
      state.crews.push({x:c.x, y:c.y, met:false, idx:i});
      occ.add(key(c.x,c.y));
    }

    // ã‚¢ã‚¤ãƒ†ãƒ é…ç½®
    state.items = [];
    state.tapeGot = 0;
    state.crewMet = 0;
    
    state.config.items.forEach(type => {
      const c = randomEmptyCell(occ);
      state.items.push({x:c.x, y:c.y, type:type, got:false});
      occ.add(key(c.x,c.y));
    });

    // æ•µé…ç½®
    state.enemies = [];
    state.config.enemies.forEach(type => {
      const c = randomEmptyCell(occ);
      // âœ… åˆæœŸä½ç½® (startX, startY) ã‚’ä¿æŒ
      state.enemies.push({x:c.x, y:c.y, startX:c.x, startY:c.y, type:type});
      occ.add(key(c.x,c.y));
    });

    state.slots = new Array(MAX_SLOTS).fill(null);
    state.runQueue = [];

    updateHUD();
    renderSlots();
    draw();
  }

  function resetAllToStart(){
    stopRun();
    unlockAudio();
    startPlayBGM();

    state.buzz = {x: state.start.x, y: state.start.y, dir: state.start.dir};
    state.stepPtr = 0;
    state.message = "ãƒªã‚»ãƒƒãƒˆï¼";

    // âœ… æ•µã®ä½ç½®ã‚‚åˆæœŸä½ç½®ã«æˆ»ã™
    state.enemies.forEach(e => {
      e.x = e.startX;
      e.y = e.startY;
    });

    state.slots = new Array(MAX_SLOTS).fill(null);
    state.runQueue = [];

    renderSlots();
    draw();
  }

  /***********************
   * æç”»
   ***********************/
  function fitCanvas(){
    const wrap = canvas.parentElement.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(wrap.width * dpr));
    canvas.height = Math.max(1, Math.floor(wrap.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  function boardRect(){
    const w = canvas.width / (window.devicePixelRatio||1);
    const h = canvas.height / (window.devicePixelRatio||1);

    const pad = 18;
    const topPad = 18;

    return {
      bx: pad,
      by: topPad,
      bw: w - pad*2,
      bh: h - pad - topPad,
      w, h
    };
  }

  function drawImageContain(img, x, y, w, h, scale=0.92){
    const iw = img.width, ih = img.height;
    if (!iw || !ih) return false;
    const s = Math.min(w/iw, h/ih) * scale;
    const dw = iw * s, dh = ih * s;
    const dx = x + (w - dw)/2;
    const dy = y + (h - dh)/2;
    ctx.drawImage(img, dx, dy, dw, dh);
    return true;
  }

  function draw(){
    const {bx,by,bw,bh,w,h} = boardRect();
    ctx.clearRect(0,0,w,h);

    const n = state.size;
    const cellW = bw / n;
    const cellH = bh / n;

    for (let yy=0;yy<n;yy++){
      for (let xx=0;xx<n;xx++){
        const x0 = bx + xx*cellW;
        const y0 = by + yy*cellH;

        // å£ã‹åºŠã‹
        if (state.board[yy] && state.board[yy][xx] === 1){
          // å£
          ctx.fillStyle = "rgba(45,55,80,0.9)";
          ctx.fillRect(x0, y0, cellW, cellH);
          ctx.strokeStyle = "rgba(100,120,150,0.5)";
          ctx.strokeRect(x0, y0, cellW, cellH);
        } else {
          // åºŠ
          ctx.fillStyle = ((xx+yy)%2===0) ? "rgba(18,26,46,0.78)" : "rgba(15,22,40,0.78)";
          ctx.fillRect(x0, y0, cellW, cellH);
          ctx.strokeStyle = "rgba(27,42,74,0.55)";
          ctx.strokeRect(x0, y0, cellW, cellH);
        }

        // ã‚¢ã‚¤ãƒ†ãƒ æç”»
        const item = state.items.find(i => i.x===xx && i.y===yy && !i.got);
        if (item){
          ctx.save();
          if (item.type === "tape"){
            ctx.fillStyle = "rgba(255,211,108,0.08)";
            ctx.fillRect(x0,y0,cellW,cellH);
            if (I.tape.ok()) drawImageContain(I.tape.img, x0, y0, cellW, cellH, 0.92);
          } else if (item.type === "mama"){
            ctx.fillStyle = "rgba(255,108,139,0.08)";
            ctx.fillRect(x0,y0,cellW,cellH);
            if (I.mama.ok()) drawImageContain(I.mama.img, x0, y0, cellW, cellH, 0.92);
          }
          ctx.restore();
        }
      }
    }

    // ã‚´ãƒ¼ãƒ«
    const gx = bx + state.goal.x*cellW;
    const gy = by + state.goal.y*cellH;
    ctx.save();
    ctx.fillStyle = "rgba(108,242,255,0.06)";
    ctx.fillRect(gx,gy,cellW,cellH);
    if (I.rocket.ok()) drawImageContain(I.rocket.img, gx, gy, cellW, cellH, 0.92);

    ctx.font = `${Math.floor(Math.min(cellW,cellH)*0.18)}px system-ui`;
    ctx.fillStyle = "rgba(233,240,255,0.95)";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText("ã‚´ãƒ¼ãƒ«", gx + cellW/2, gy + cellH*0.03);
    ctx.restore();

    // ã‚¹ã‚¿ãƒ¼ãƒˆï¼ˆé–‹å§‹ä½ç½®å›ºå®šï¼‰
    const sx = bx + state.start.x*cellW;
    const sy = by + state.start.y*cellH;
    ctx.save();
    ctx.fillStyle = "rgba(118,255,157,0.05)";
    ctx.fillRect(sx,sy,cellW,cellH);
    ctx.font = `${Math.floor(Math.min(cellW,cellH)*0.18)}px system-ui`;
    ctx.fillStyle = "rgba(233,240,255,0.95)";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText("ã‚¹ã‚¿ãƒ¼ãƒˆ", sx + cellW/2, sy + cellH*0.03);
    ctx.restore();

    // ã‚¯ãƒ«ãƒ¼ï¼ˆå›ºå®š/3äººï¼‰
    state.crews.forEach((c)=>{
      if (c.met) return;
      const x0 = bx + c.x*cellW, y0 = by + c.y*cellH;
      ctx.save();
      ctx.fillStyle = "rgba(118,255,157,0.05)";
      ctx.fillRect(x0,y0,cellW,cellH);
      const src = (c.idx===0) ? I.crew1 : (c.idx===1 ? I.crew2 : I.crew3);
      if (src.ok()) drawImageContain(src.img, x0, y0, cellW, cellH, 0.92);
      ctx.restore();
    });

    // ãƒã‚ºï¼ˆå‘ãåˆ¥ç”»åƒï¼‰
    const px = bx + state.buzz.x*cellW;
    const py = by + state.buzz.y*cellH;
    ctx.save();
    ctx.fillStyle = "rgba(108,242,255,0.04)";
    ctx.fillRect(px,py,cellW,cellH);
    const bi = buzzImgForDir(state.buzz.dir);
    if (bi.ok()) drawImageContain(bi.img, px, py, cellW, cellH, 0.92);
    ctx.restore();

    // æ•µ
    state.enemies.forEach(e => {
      const ex = bx + e.x*cellW;
      const ey = by + e.y*cellH;
      ctx.save();
      if (e.type === "kaiju"){
        if (I.kaiju.ok()) drawImageContain(I.kaiju.img, ex, ey, cellW, cellH, 0.92);
      }
      ctx.restore();
    });

    if (state.message){
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0, h-46, w, 46);
      ctx.fillStyle = "rgba(233,240,255,0.92)";
      ctx.font = "16px system-ui";
      ctx.textAlign = "left";
      ctx.textBaseline = "alphabetic";
      ctx.fillText(state.message, 14, h-18);
      ctx.restore();
    }
  }

  /***********************
   * å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯
   ***********************/
  function dirVec(dir){
    if (dir===0) return {dx:0,dy:-1};
    if (dir===1) return {dx:1,dy:0};
    if (dir===2) return {dx:0,dy:1};
    return {dx:-1,dy:0};
  }
  function samePos(a,b){ return a.x===b.x && a.y===b.y; }

  function checkPickups(){
    // ã‚¢ã‚¤ãƒ†ãƒ å–å¾—
    const itemIndex = state.items.findIndex(i => i.x===state.buzz.x && i.y===state.buzz.y && !i.got);
    if (itemIndex !== -1){
      const item = state.items[itemIndex];
      item.got = true;
      if (item.type === "tape"){
        state.tapeGot++;
        state.score += 80;
        state.message = "ãƒ†ãƒ¼ãƒ— ã¿ã£ã‘ï¼";
        playSfx(SND.itemSfx, 0.95);
      } else if (item.type === "mama"){
        state.score += 300;
        state.message = "ã¾ã¾ã¨ã„ã£ã—ã‚‡ã ã‚ˆ";
        playSfx(SND.itemSfx, 0.95);
        // âœ… è¿½åŠ ï¼šãƒãƒå–å¾—æ™‚ã®å‹•ç”»å†ç”Ÿ
        playInterruptVideo(SND.mamaSfx, MOV.mamaMp4, () => {
          startRun(); // å†ç”Ÿçµ‚äº†å¾Œã€ã‚²ãƒ¼ãƒ ï¼ˆstartRunã®çŠ¶æ…‹ï¼‰ã«å¾©å¸°ã•ã›ã‚‹
        });
      }
    }

    // ã‚¯ãƒ«ãƒ¼æ•‘åŠ©
    state.crews.forEach(c=>{
      if (c.met) return;
      if (c.x===state.buzz.x && c.y===state.buzz.y){
        c.met=true;
        state.crewMet++;
        state.score += 120;
        state.message = "ã‚¯ãƒ«ãƒ¼ã« ã‚ãˆãŸï¼";
        playSfx(SND.itemSfx, 0.9);
      }
    });
    updateHUD();
  }

  function failAndAutoReset(msg){
    stopRun();
    playSfx(SND.cmdSfx, 0.35);
    state.buzz = {x: state.start.x, y: state.start.y, dir: state.start.dir};
    state.stepPtr = 0;
    state.message = msg || "ã—ã£ã±ã„ï¼ ã‚‚ã©ã‚‹ã‚ˆã€‚";

    // âœ… æ•µã®ä½ç½®ã‚‚åˆæœŸä½ç½®ã«æˆ»ã™
    state.enemies.forEach(e => {
      e.x = e.startX;
      e.y = e.startY;
    });

    draw();
  }

  function startRun(){
    if (!started) return;
    unlockAudio();
    startPlayBGM();

    state.runQueue = state.slots.filter(Boolean);
    if (state.runQueue.length === 0){
      state.message="ã¾ãš ãªã‚‰ã¹ã¦ã­ã€‚";
      draw();
      return;
    }

    // âœ… ã‚¹ã‚¿ãƒ¼ãƒˆã—ãŸã‚‰ã‚³ãƒãƒ³ãƒ‰æ¶ˆã™
    state.slots = new Array(MAX_SLOTS).fill(null);
    renderSlots();

    state.running=true;
    state.stepPtr=0;
    state.message="";

    btnStart.disabled=true;
    btnReset.disabled=true;
    btnClear.disabled=true;

    draw();
    timer = setInterval(stepOnce, state.tickMs);
  }

  // BFSã§æœ€çŸ­çµŒè·¯ã®æ¬¡ã®1æ­©ã‚’æ±‚ã‚ã‚‹
  function getNextEnemyMove(enemy, target){
    const q = [{x:enemy.x, y:enemy.y, path:[]}];
    const visited = new Set([key(enemy.x, enemy.y)]);
    
    // æ¢ç´¢åˆ¶é™ï¼ˆé‡ããªã‚Šã™ããªã„ã‚ˆã†ï¼‰
    let limit = 400;

    while(q.length > 0 && limit-- > 0){
      const cur = q.shift();
      if (cur.x === target.x && cur.y === target.y){
        return cur.path[0]; // æœ€åˆã®1æ­©
      }

      const dirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
      for(const d of dirs){
        const nx = cur.x + d.dx;
        const ny = cur.y + d.dy;
        // ç¯„å›²å¤– or å£
        if (nx<0 || nx>=state.size || ny<0 || ny>=state.size) continue;
        if (state.board[ny][nx] === 1) continue;
        
        const k = key(nx, ny);
        if (!visited.has(k)){
          visited.add(k);
          const newPath = [...cur.path, {x:nx, y:ny}];
          q.push({x:nx, y:ny, path:newPath});
        }
      }
    }
    return null; // çµŒè·¯ãªã—
  }

  function stepOnce(){
    const cmd = state.runQueue[state.stepPtr];
    if (!cmd){
      stopRun();
      state.message="ã‚³ãƒãƒ³ãƒ‰ ãŠã‚ã‚Šã€‚";
      draw();
      return;
    }

    if (cmd==="L") state.buzz.dir = (state.buzz.dir + 3) % 4;
    if (cmd==="R") state.buzz.dir = (state.buzz.dir + 1) % 4;
    if (cmd==="U") state.buzz.dir = (state.buzz.dir + 2) % 4;

    if (cmd==="F"){
      const v = dirVec(state.buzz.dir);
      const nx = state.buzz.x + v.dx;
      const ny = state.buzz.y + v.dy;
      
      // æ å¤–ãƒã‚§ãƒƒã‚¯
      if (nx<0||nx>=state.size||ny<0||ny>=state.size){
        failAndAutoReset("ãã¨ã ã‚ˆï¼ ã‚‚ã©ã‚‹ã­ã€‚");
        return;
      }
      // å£ãƒã‚§ãƒƒã‚¯
      if (state.board[ny][nx] === 1){
        // å£ãªã‚‰é€²ã¾ãªã„ï¼ˆãã®å ´ã§è¶³è¸ã¿ï¼‰
        playSfx(SND.walkSfx, 0.35);
        state.message = "ã‹ã¹ã ã‚ˆï¼";
      } else {
        state.buzz.x = nx; state.buzz.y = ny;
        playSfx(SND.walkSfx, 0.35);
      }
    }

    checkPickups();

    // æ•µã®ç§»å‹•ï¼ˆ2ã‚¿ãƒ¼ãƒ³ã«1å›ï¼‰
    state.turn++;
    if (state.turn % 2 === 0){
      state.enemies.forEach(e => {
        if (e.type === "kaiju"){
          const nextPos = getNextEnemyMove(e, state.buzz);
          if (nextPos){
            e.x = nextPos.x;
            e.y = nextPos.y;
          }
        }
      });
    }

    // æ•µã¨ã®æ¥è§¦åˆ¤å®š
    const hitEnemy = state.enemies.some(e => e.x === state.buzz.x && e.y === state.buzz.y);
    if (hitEnemy){
      state.kaijuCatchCount++; // âœ… è¿½åŠ ï¼šæ•ã¾ã£ãŸå›æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
      
      if (state.kaijuCatchCount === 3) {
        // âœ… 3å›ç›®ãªã‚‰ç‰¹åˆ¥ãªå‹•ç”»ã‚’å†ç”Ÿ
        playInterruptVideo(SND.yuaSfx, MOV.yuaMp4, () => {
          failAndAutoReset("ã‚Šãã«ã„ã€ã„ã£ã—ã‚‡ã«ã‚ãƒ¼ãã¼");
        });
      } else {
        failAndAutoReset("ã‚Šãã«ã„ã€ã„ã£ã—ã‚‡ã«ã‚ãƒ¼ãã¼");
      }
      return;
    }

    // æ•µãŒè¿‘ãã«ã„ã‚‹ã‹ï¼Ÿ
    const nearEnemy = state.enemies.some(e => manhattan(e, state.buzz) <= 3);
    if (nearEnemy){
      state.message = "ã‚†ã‚ã¡ã‚ƒã‚“ã‹ã„ã˜ã‚…ã†ãŒ ãã“ã¾ã§ãã¦ã„ã‚‹ï¼";
    }

    if (samePos(state.buzz, state.goal)){
      // ã‚´ãƒ¼ãƒ«æ¡ä»¶ãƒã‚§ãƒƒã‚¯
      // ãƒãƒã‚¹ãƒ†ãƒ¼ã‚¸(Stage 6, 8)ã®å ´åˆã€ãƒãƒã‚’æŒã£ã¦ã„ãªã„ã¨å…¥ã‚Œãªã„
      // User Request: if (stageIndex === 5 && !state.hasMom) -> indexãŒå¤‰ã‚ã£ãŸã®ã§èª¿æ•´
      // Stage 5(ãƒãƒå˜ä½“), Stage 7(ãƒãƒï¼†é¬¼) ã§é©ç”¨
      const mamaItem = state.items.find(i => i.type === "mama");
      const hasMom = mamaItem && mamaItem.got;
      
      // itemsã«mamaãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‚¹ãƒ†ãƒ¼ã‚¸ãªã‚‰ãƒã‚§ãƒƒã‚¯ã™ã‚‹å½¢ã«æ±ç”¨åŒ–
      const needsMama = state.config.items.includes("mama");

      if (needsMama && !hasMom){
        // ã‚´ãƒ¼ãƒ«ã«å…¥ã‚ã†ã¨ã—ãŸãŒå¼¾ã‹ã‚Œã‚‹
        // 1æ­©æˆ»ã™ï¼ˆç°¡æ˜“çš„ï¼‰
        if (cmd==="F"){
          const v = dirVec(state.buzz.dir);
          state.buzz.x -= v.dx;
          state.buzz.y -= v.dy;
        }
        state.message = "ãƒãƒãŒã‚ˆã‚“ã§ã„ã‚‹ã‚ˆï¼";
        draw();
        state.stepPtr++; // ã‚³ãƒãƒ³ãƒ‰ã¯æ¶ˆè²»ã™ã‚‹
        return;
      }

      stopRun();
      state.score += 200;
      updateHUD();

      playSfx(SND.goalSfx, 1.0);
      stopPlayBGM();
      startGoalBGM();

      // ã‚¯ãƒªã‚¢ç”»é¢ï¼šç”»åƒè¡¨ç¤ºã«æˆ»ã™
      nextVideoEl.pause(); nextVideoEl.removeAttribute("src"); nextVideoEl.load();
      nextVideoEl.classList.remove("show");
      nextSpaceImgEl.style.display = "block";

      overlay.classList.add("show");
      return;
    }

    state.stepPtr++;
    draw();
  }

  async function playNextSequence(){
    // âœ… iOSã¯ã€Œãƒœã‚¿ãƒ³æŠ¼ä¸‹ï¼ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã€ä¸­ã«playã‚’é–‹å§‹ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
    unlockAudio();

    // ã¾ãšéŸ³
    playSfx(SND.nextSfx, 1.0);

    // BGMæ­¢ã‚ã‚‹ï¼ˆå‹•ç”»ã®éŸ³ãŒèã“ãˆã‚‹ã‚ˆã†ã«ï¼‰
    stopGoalBGM();
    stopPlayBGM();

    // å‹•ç”»ã‚’è¡¨ç¤ºï¼†å†ç”Ÿ
    nextSpaceImgEl.style.display = "none";
    nextVideoEl.classList.add("show");
    nextVideoEl.src = MOV.nextMp4;
    nextVideoEl.currentTime = 0;
    nextVideoEl.muted = false;
    nextVideoEl.controls = false;
    
    // ã‚¹ã‚­ãƒƒãƒ—ãƒœã‚¿ãƒ³è¡¨ç¤º
    btnSkip.style.display = "block";

    let resolveFunc = null;
    const p = new Promise(resolve=>{ resolveFunc = resolve; });

    const endHandler = () => {
      cleanup();
      resolveFunc();
    };
    
    const skipHandler = () => {
      nextVideoEl.pause();
      cleanup();
      resolveFunc();
    };

    const cleanup = () => {
      nextVideoEl.removeEventListener("ended", endHandler);
      btnSkip.removeEventListener("click", skipHandler);
      btnSkip.style.display = "none";
    };

    nextVideoEl.addEventListener("ended", endHandler, {once:true});
    btnSkip.addEventListener("click", skipHandler, {once:true});

    try{
      await nextVideoEl.play(); 
    }catch(e){
      nextVideoEl.controls = true;
      try{ await nextVideoEl.play(); }catch(_){}
    }

    await p;
  }

  function nextStage(){
    overlay.classList.remove("show");
    stageIndex++;
    if (stageIndex >= STAGES.length){
      stageIndex = 0;
      state.score = 0;
    }
    resetStage();
  }

  /***********************
   * èµ·å‹•ç”»é¢
   ***********************/
  function showStart(){
    startOverlay.style.display = "flex";
  }

  async function beginGame(){
    // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ã§éŸ³ã®ãƒ­ãƒƒã‚¯è§£é™¤
    unlockAudio();

    // ã¯ã˜ã‚ã‚‹BGMã‚’é–‹å§‹ â†’ ãƒœã‚¿ãƒ³éŸ³
    startBeginBGM();
    playSfx(SND.beginBtn, 1.0);

    // å°‘ã—å¾…ã£ã¦ã‹ã‚‰ã‚²ãƒ¼ãƒ é–‹å§‹ï¼ˆæ¼”å‡ºï¼‰
    await new Promise(r=>setTimeout(r, 400));

    stopBeginBGM();
    started = true;
    startOverlay.style.display = "none";
    resetStage();
    startPlayBGM();
  }

  /***********************
   * ã‚¤ãƒ™ãƒ³ãƒˆ
   ***********************/
  btnStart.addEventListener("click", ()=> startRun());
  btnReset.addEventListener("click", ()=>{ if(started){ unlockAudio(); resetAllToStart(); } });
  btnClear.addEventListener("click", ()=>{ if(started){ unlockAudio(); startPlayBGM(); clearCommands(); } });
  
  // è¿·è·¯çµ„ã¿æ›ãˆãƒœã‚¿ãƒ³
  btnShuffle.addEventListener("click", ()=>{
    if(!started) return;
    unlockAudio();
    resetStage(); // åŒã˜ã‚¹ãƒ†ãƒ¼ã‚¸ç•ªå·ã§ãƒªã‚»ãƒƒãƒˆï¼å†ç”Ÿæˆ
  });

  btnNext.addEventListener("click", async ()=>{
    if (!started) return;
    btnNext.disabled = true;
    try{
      await playNextSequence();   // âœ… ã¤ãã¸.mp3 â†’ ã¤ãã¸.mp4
      nextStage();
    } finally {
      btnNext.disabled = false;
    }
  });

  overlay.addEventListener("click", (e)=>{
    // èƒŒæ™¯ã‚¿ãƒƒãƒ—ã§é€²ã‚€ã®ã¯ã‚„ã‚ã‚‹ï¼ˆèª¤ã‚¿ãƒƒãƒ—é˜²æ­¢ï¼‰ã€‚å¿…è¦ãªã‚‰æˆ»ã™
    // if (e.target===overlay){ nextStage(); }
  });

  btnBegin.addEventListener("click", ()=> beginGame());

  window.addEventListener("resize", ()=>{
    fitCanvas();
    draw();
  });

  // init
  buildCmdList();
  buildSlots();
  fitCanvas();
  showStart();
})();
</script>
</body>
</html>
